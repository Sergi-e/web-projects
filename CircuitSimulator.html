<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Logic Circuit Simulator (Logisim style, ≤3 inputs)</title>
<style>
:root{
  --bg:#f7fafc; --card:#ffffff; --fg:#0f1724; --muted:#475569;
  --border:#e6eef6; --good:#10b981; --bad:#ef4444; --wireOn:red; --wireOff:blue;
}
body.dark{ --bg:#0d1117; --card:#0f1720; --fg:#e6eef3; --border:#263238; }
body{ margin:0; background:var(--bg); color:var(--fg); font-family:Inter,system-ui,Arial; padding:18px; display:flex; justify-content:center; }
.app{ width:98%; max-width:1280px; }
.card{ background:var(--card); border:1px solid var(--border); border-radius:10px; padding:12px; margin-bottom:14px; }
.header-row{ display:flex; align-items:center; justify-content:space-between; }
.controls{ display:flex; gap:8px; align-items:center; margin-top:10px; }
input[type="text"]{ padding:8px; border-radius:8px; border:1px solid var(--border); background:transparent; color:var(--fg); }
button{ background:#0b7285; color:white; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; }
button.secondary{ background:#94a3b8; color:white; }
.small{ font-size:13px; color:var(--muted); }
.inputsGrid{ display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; }
.inputBox{ display:flex; gap:8px; align-items:center; background:var(--card); border:1px solid var(--border); padding:8px; border-radius:8px; }
#svgwrap{ height:520px; overflow:auto; border:1px solid var(--border); border-radius:8px; background:var(--card); margin-left:12px; }
.row{ display:flex; gap:12px; align-items:flex-start; }
.result{ display:inline-block; padding:6px 10px; border-radius:8px; border:1px solid var(--border); margin-left:8px; font-weight:700; background:var(--card); }
table{ width:100%; border-collapse:collapse; margin-top:10px; }
th,td{ border:1px solid var(--border); padding:8px; text-align:center; font-size:14px; }
.modeBtn{ background:#0b7285; color:#fff; border:none; padding:8px 10px; border-radius:8px; cursor:pointer; }
svg{ width:1200px; height:1200px; }
</style>
</head>
<body>
<div class="app">
  <div class="card header-row">
    <div>
      <h2 style="margin:0">Logic Circuit Simulator</h2>
      <div class="small">Logisim-like gates, inputs left, outputs right — gates up to 3 inputs each.</div>
    </div>
    <div>
      <button id="modeBtn" class="modeBtn">Dark mode</button>
    </div>
  </div>

  <section class="card row" style="align-items:flex-start">
    <div style="flex:1; min-width:360px;">
      <label class="small">Expression</label>
      <input id="expr" type="text" value="(A and B) or C" />
      <div class="controls">
        <button id="parseBtn">Parse and draw</button>
        <button id="applyBtn" class="secondary">Apply inputs</button>
        <span id="status" class="small" style="margin-left:8px"></span>
      </div>

      <div id="inputsArea" class="inputsGrid"></div>

      <div style="margin-top:12px;">
        <span class="small">Output:</span><span id="outputBadge" class="result">—</span>
      </div>
    </div>

    <div id="svgwrap" class="card" style="flex:1; padding:10px;">
      <svg id="svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1400 1200" preserveAspectRatio="xMinYMin meet"></svg>
    </div>
  </section>

  <section class="card">
    <h3 class="small">Truth Table</h3>
    <div id="tableWrap"></div>
  </section>
</div>

<script>
/* ---------- Parser, normalization ---------- */
function normalizeWords(s){
  return s.replace(/\bAND\b/gi,'&')
          .replace(/\bOR\b/gi,'|')
          .replace(/\bNOT\b/gi,'!')
          .replace(/\bXOR\b/gi,'^')
          .replace(/<__?>/g,'<->')
          .replace(/→/g,'->').replace(/↔/g,'<->');
}
function tokenize(s){
  if(!s) return [];
  s = normalizeWords(s);
  const re = /\s*([A-Za-z][A-Za-z0-9_]*|<->|->|\(|\)|~|!|&|\||\^|¬|∧|∨)\s*/g;
  const out=[]; let m;
  while((m=re.exec(s))!==null){
    const tk = m[1];
    if(/^[A-Za-z]/.test(tk)) out.push(tk.toUpperCase());
    else out.push(tk);
  }
  return out;
}
const prec = {'!':5,'~':5,'&':4,'^':3,'|':2,'->':1,'<->':0};
function toPostfix(tokens){
  const out=[], ops=[];
  const isU = t=>t==='!'||t==='~';
  for(const t0 of tokens){
    let t=t0;
    if(/^[A-Z]/.test(t)) out.push({type:'var', val:t});
    else if(isU(t)) ops.push(t);
    else if(t==='(') ops.push(t);
    else if(t===')'){ while(ops.length && ops.at(-1)!=='(') out.push({type:'op', val:ops.pop()}); ops.pop(); }
    else {
      if(t==='¬') t='!'; if(t==='∧') t='&'; if(t==='∨') t='|';
      while(ops.length && ops.at(-1)!=='(' && (prec[ops.at(-1)] >= (prec[t]||0))) out.push({type:'op', val:ops.pop()});
      ops.push(t);
    }
  }
  while(ops.length) out.push({type:'op', val:ops.pop()});
  return out;
}
function postfixToAST(pf){
  const st=[];
  for(const tk of pf){
    if(tk.type==='var') st.push({kind:'VAR', name:tk.val});
    else {
      const op=tk.val;
      if(op==='!'||op==='~'){ const a=st.pop(); st.push({kind:'NOT', child:a}); }
      else { const b=st.pop(), a=st.pop(); const kind = (op==='&'?'AND':op==='|'?'OR':op==='^'?'XOR':op); st.push({kind:kind, left:a, right:b}); }
    }
  }
  if(st.length!==1) throw 'Invalid expression';
  return st[0];
}
function desugar(node){
  if(!node) return node;
  if(node.kind==='VAR') return node;
  if(node.kind==='NOT') return {kind:'NOT', child: desugar(node.child)};
  const L=desugar(node.left), R=desugar(node.right);
  if(node.kind==='->') return {kind:'OR', left:{kind:'NOT', child:L}, right:R};
  if(node.kind==='<->') return { kind:'OR', left:{kind:'AND', left:L, right:R}, right:{kind:'AND', left:{kind:'NOT',child:L}, right:{kind:'NOT',child:R}} };
  return {kind:node.kind, left:L, right:R};
}
function parseExpression(s){
  if(!s||!s.trim()) throw 'Empty expression';
  const tokens = tokenize(s);
  if(!tokens.length) throw 'No tokens found';
  const pf = toPostfix(tokens);
  const ast0 = postfixToAST(pf);
  return desugar(ast0);
}

/* ---------- convert binary AST to n-ary up to 3-input gates ---------- */
function flattenToNAry(node){
  if(!node) return node;
  if(node.kind==='VAR') return node;
  if(node.kind==='NOT') return {kind:'NOT', child: flattenToNAry(node.child)};
  // For AND, OR, XOR: flatten chains of the same operator into an inputs array, up to 3 per gate.
  if(node.kind==='AND' || node.kind==='OR' || node.kind==='XOR'){
    const kind=node.kind;
    const collect = (n, acc) => {
      if(!n) return;
      if(n.kind===kind){
        // recurse into left and right
        collect(n.left, acc);
        collect(n.right, acc);
      } else acc.push(flattenToNAry(n));
    };
    const acc=[]; collect(node, acc);
    // create chain of gates each with up to 3 inputs
    // if acc.length <=3 return {kind, inputs:acc}
    if(acc.length <=3) return {kind:kind, inputs: acc.map(x=>flattenToNAry(x))};
    // else build left-associative chain of gates each 3-input
    // e.g. A B C D E => gate1(inputs A,B,C) => gate2(inputs gate1, D, E) => ...
    let idx=0;
    const makeGate = (leftover) => {
      if(leftover.length <=3) return {kind:kind, inputs: leftover.map(x=>flattenToNAry(x))};
      const first = leftover.slice(0,3);
      const rest = leftover.slice(3);
      const g = {kind:kind, inputs: first.map(x=>flattenToNAry(x))};
      // then push g into rest front
      return makeGate([g].concat(rest));
    };
    return makeGate(acc);
  }
  // binary other kinds
  return {kind:node.kind, left: flattenToNAry(node.left), right: flattenToNAry(node.right)};
}

/* ---------- evaluation for n-ary nodes ---------- */
function evaluate(node, assign){
  if(!node) return false;
  if(node.kind==='VAR') return !!assign[node.name];
  if(node.kind==='NOT') return !evaluate(node.child, assign);
  if(node.kind==='AND'){ // n-ary or binary
    if(node.inputs) return node.inputs.reduce((a,c)=>a && evaluate(c,assign), true);
    return evaluate(node.left,assign) && evaluate(node.right,assign);
  }
  if(node.kind==='OR'){
    if(node.inputs) return node.inputs.reduce((a,c)=>a || evaluate(c,assign), false);
    return evaluate(node.left,assign) || evaluate(node.right,assign);
  }
  if(node.kind==='XOR'){
    if(node.inputs){
      // XOR of many: parity
      const parity = node.inputs.reduce((p,c)=> p ^ (evaluate(c,assign)?1:0), 0);
      return !!parity;
    }
    return !!(evaluate(node.left,assign) ^ evaluate(node.right,assign));
  }
  return false;
}
function collectVars(node, set){
  if(!node) return;
  if(node.kind==='VAR') set.add(node.name);
  if(node.kind==='NOT') collectVars(node.child, set);
  if(node.inputs) { node.inputs.forEach(i=>collectVars(i,set)); return; }
  if(node.left) collectVars(node.left, set);
  if(node.right) collectVars(node.right, set);
}

/* ---------- layout ---------- */
function layoutTree(root){
  // simple depth and inorder for vertical placement (left=inputs, right=output)
  const nodes=[];
  function dfs(n,depth){ if(!n)return; n._depth=depth; nodes.push(n); if(n.kind==='NOT') dfs(n.child, depth+1); else if(n.inputs) { n.inputs.forEach(i=>dfs(i, depth+1)); } else if(n.left){ dfs(n.left, depth+1); dfs(n.right, depth+1); } }
  dfs(root, 0);
  let y=0;
  function inorder(n){
    if(!n) return;
    if(n.kind==='VAR'){ n._y = y++; return; }
    if(n.kind==='NOT'){ inorder(n.child); n._y = y++; return; }
    if(n.inputs){
      n.inputs.forEach(inp=>inorder(inp));
      n._y = y++;
      return;
    }
    inorder(n.left); inorder(n.right); n._y = y++;
  }
  inorder(root);
  nodes.forEach(n=>{ n._x = n._depth; n._xpos = 120 + n._x * 260; n._ypos = 60 + n._y * 90; });
  return nodes;
}

/* ---------- Logisim-like gate drawing (inputs on left, output right), wires right-angle ---------- */
const GATE_STROKE="black", GATE_FILL="white", GATE_W=2;
function drawAND(svg, x,y){
  const w=88,h=46; const left=x-w/2, top=y-h/2; const r=h/2;
  const p=document.createElementNS("http://www.w3.org/2000/svg","path");
  const d=`M ${left} ${top} L ${left + w/2} ${top} A ${r} ${r} 0 0 1 ${left + w/2} ${top + h} L ${left} ${top + h} Z`;
  p.setAttribute("d",d); p.setAttribute("fill",GATE_FILL); p.setAttribute("stroke",GATE_STROKE); p.setAttribute("stroke-width",GATE_W);
  svg.appendChild(p);
  return {el:p, inLeft: left, inRight:left + 18, outX:left + w/2 + 6};
}
function drawOR(svg,x,y){
  // smoother OR with back curve
  const w=110,h=60; const left=x-w/2, top=y-h/2; const back=left-20;
  const p=document.createElementNS("http://www.w3.org/2000/svg","path");
  const d=`M ${back} ${top}
           C ${left+6} ${top} ${left + (w*0.25)} ${top} ${left + (w*0.5)} ${top}
           C ${left + (w*0.9)} ${top} ${left + w} ${top + h*0.25} ${left + w} ${top + h/2}
           C ${left + w} ${top + h*0.75} ${left + (w*0.9)} ${top + h} ${left + (w*0.5)} ${top + h}
           C ${left + (w*0.25)} ${top + h} ${left+6} ${top + h} ${back} ${top + h}
           C ${left + 14} ${top + h/2} ${left + 14} ${top + h/2} ${back} ${top}
           Z`;
  p.setAttribute("d", d); p.setAttribute("fill",GATE_FILL); p.setAttribute("stroke",GATE_STROKE); p.setAttribute("stroke-width",GATE_W);
  svg.appendChild(p);
  return {el:p, inLeft: left-6, outX: left + w*0.55};
}
function drawXOR(svg,x,y){
  // OR + front arc
  const r = drawOR(svg,x,y);
  const w=110,h=60; const left=x-w/2, top=y-h/2; const ax=left-14;
  const arc=document.createElementNS("http://www.w3.org/2000/svg","path");
  const ad=`M ${ax} ${top} C ${ax+10} ${top + h*0.12} ${ax+10} ${top + h*0.88} ${ax} ${top + h}`;
  arc.setAttribute("d",ad); arc.setAttribute("fill","none"); arc.setAttribute("stroke",GATE_STROKE); arc.setAttribute("stroke-width",GATE_W);
  svg.appendChild(arc);
  return {el:r.el, inLeft: ax - 6, outX: r.outX};
}
function drawNOT(svg,x,y){
  const w=56,h=44; const left=x-w/2, top=y-h/2;
  const tri=document.createElementNS("http://www.w3.org/2000/svg","path");
  tri.setAttribute("d",`M ${left} ${top} L ${left + w} ${y} L ${left} ${top + h} Z`);
  tri.setAttribute("fill",GATE_FILL); tri.setAttribute("stroke",GATE_STROKE); tri.setAttribute("stroke-width",GATE_W);
  svg.appendChild(tri);
  const r=6; const cx=left + w + r + 2;
  const c=document.createElementNS("http://www.w3.org/2000/svg","circle");
  c.setAttribute("cx",cx); c.setAttribute("cy",y); c.setAttribute("r",r); c.setAttribute("fill",GATE_FILL); c.setAttribute("stroke",GATE_STROKE); c.setAttribute("stroke-width",GATE_W);
  svg.appendChild(c);
  return {el:tri, inLeft:left-6, outX:cx + r};
}
function drawVAR(svg,node){
  const x=node._xpos, y=node._ypos;
  const g=document.createElementNS("http://www.w3.org/2000/svg","g"); g.setAttribute("transform",`translate(${x},${y})`);
  const rect=document.createElementNS("http://www.w3.org/2000/svg","rect");
  rect.setAttribute("x","-28"); rect.setAttribute("y","-16"); rect.setAttribute("width","56"); rect.setAttribute("height","32"); rect.setAttribute("rx","8");
  rect.setAttribute("fill",GATE_FILL); rect.setAttribute("stroke",GATE_STROKE); rect.setAttribute("stroke-width","2");
  const t=document.createElementNS("http://www.w3.org/2000/svg","text"); t.setAttribute("x","0"); t.setAttribute("y","6"); t.setAttribute("text-anchor","middle"); t.setAttribute("font-size","13"); t.textContent=node.name;
  g.appendChild(rect); g.appendChild(t); svg.appendChild(g);
  return {el:g, outX:x+28, pinX:x-40, pinY:y};
}
function drawWire(svg,x1,y1,x2,y2,val){
  const midX=(x1+x2)/2;
  const path=document.createElementNS("http://www.w3.org/2000/svg","path");
  const d=`M ${x1} ${y1} L ${midX} ${y1} L ${midX} ${y2} L ${x2} ${y2}`;
  path.setAttribute("d",d); path.setAttribute("stroke", val? "var(--wireOn)":"var(--wireOff)"); path.setAttribute("stroke-width","3"); path.setAttribute("fill","none"); path.setAttribute("stroke-linecap","square");
  svg.appendChild(path);
}

/* ---------- compose render with n-ary gates (≤3 inputs) ---------- */
function clearSVG(svg){ while(svg.firstChild) svg.removeChild(svg.firstChild); }

function drawCircuit(svg, root, assign){
  clearSVG(svg);
  if(!root) return;
  const nodes = layoutTree(root);
  const map = new Map();
  // draw nodes
  for(const n of nodes){
    if(n.kind==='VAR') map.set(n, drawVAR(svg,n));
    else if(n.kind==='AND') map.set(n, drawAND(svg,n._xpos,n._ypos));
    else if(n.kind==='OR') map.set(n, drawOR(svg,n._xpos,n._ypos));
    else if(n.kind==='XOR') map.set(n, drawXOR(svg,n._xpos,n._ypos));
    else if(n.kind==='NOT') map.set(n, drawNOT(svg,n._xpos,n._ypos));
    else map.set(n, drawVAR(svg,n));
  }
  // draw connections; single output per gate always
  function connect(n){
    if(n.kind==='VAR') return;
    if(n.kind==='NOT'){
      const child = n.child;
      const rc=map.get(child), rn=map.get(n);
      const x1= rc.outX !== undefined ? rc.outX : (child._xpos + 28);
      const y1= child._ypos;
      const x2= rn.inLeft !== undefined ? rn.inLeft : (n._xpos - 12);
      const y2= n._ypos;
      drawWire(svg,x1,y1,x2,y2, evaluate(child,assign));
      connect(child);
      return;
    }
    // n-ary inputs
    const ins = n.inputs ? n.inputs : [n.left, n.right];
    // if <=3 inputs, space their y positions around gate center
    const count = ins.length;
    const spacing = 12;
    for(let i=0;i<count;i++){
      const inNode = ins[i];
      const rc = map.get(inNode);
      const x1 = rc.outX !== undefined ? rc.outX : (inNode._xpos + 28);
      const y1 = inNode._ypos;
      // compute target y offset
      let y2 = n._ypos;
      if(count===1) y2 = n._ypos;
      else if(count===2) y2 = n._ypos + (i===0?-8:8);
      else y2 = n._ypos + (i-1)*spacing; // three: -spacing, 0, +spacing
      const x2 = (map.get(n).inLeft !== undefined) ? map.get(n).inLeft : (n._xpos - 12);
      drawWire(svg, x1, y1, x2, y2, evaluate(inNode,assign));
      connect(inNode);
    }
  }
  connect(root);

  // color gates and var boxes by output
  for(const n of nodes){
    const r = map.get(n);
    const outv = evaluate(n, assign);
    // color rectangles or paths if possible
    if(n.kind==='VAR'){
      const rect = r.el.querySelector('rect');
      if(rect){ rect.setAttribute('fill', outv ? '#ecfffa' : GATE_FILL); rect.setAttribute('stroke', outv ? '#bbf7d0' : GATE_STROKE); }
    } else {
      // r.el might be a path element
      if(r.el && r.el.tagName==='path'){
        r.el.setAttribute('fill', outv ? '#ecfffa' : GATE_FILL);
        r.el.setAttribute('stroke', outv ? '#bbf7d0' : GATE_STROKE);
      }
    }
  }
}

/* ---------- truth table generation ---------- */
function buildTruthTable(ast){
  const wrap = document.getElementById('tableWrap');
  if(!ast){ wrap.innerHTML=''; return; }
  const s=new Set(); collectVars(ast,s);
  const vars = Array.from(s).sort();
  if(vars.length>12){ wrap.innerHTML='<div class="small">Too many variables to show truth table (limit 12)</div>'; return; }
  const n=vars.length; const total=1<<n;
  const table=document.createElement('table');
  const thead=document.createElement('thead'); const thr=document.createElement('tr');
  vars.forEach(v=>{ const th=document.createElement('th'); th.textContent=v; thr.appendChild(th); });
  const thO=document.createElement('th'); thO.textContent='OUT'; thr.appendChild(thO);
  thead.appendChild(thr); table.appendChild(thead);
  const tbody=document.createElement('tbody');
  for(let i=0;i<total;i++){
    const tr=document.createElement('tr'); const assign={};
    for(let j=0;j<n;j++){
      const bit= !!((i >> (n-1-j)) & 1);
      assign[vars[j]] = bit;
      const td=document.createElement('td'); td.textContent = bit ? '1':'0'; tr.appendChild(td);
    }
    const outv = evaluate(ast, assign);
    const tdout=document.createElement('td'); tdout.textContent = outv ? '1':'0'; tr.appendChild(tdout); tbody.appendChild(tr);
  }
  table.appendChild(tbody); wrap.innerHTML=''; wrap.appendChild(table);
}

/* ---------- UI glue ---------- */
const exprInput = document.getElementById('expr');
const parseBtn = document.getElementById('parseBtn');
const applyBtn = document.getElementById('applyBtn');
const statusEl = document.getElementById('status');
const inputsArea = document.getElementById('inputsArea');
const svg = document.getElementById('svg');
const outputBadge = document.getElementById('outputBadge');
const modeBtn = document.getElementById('modeBtn');

let currentAST = null;
let currentVars = [];

function setStatus(msg, ok=true){ statusEl.textContent = msg; statusEl.style.color = ok ? 'var(--good)' : 'var(--bad)'; }

function buildInputs(vars){
  inputsArea.innerHTML = '';
  currentVars = vars;
  vars.forEach(v=>{
    const box = document.createElement('div'); box.className='inputBox';
    box.innerHTML = `<label style="font-weight:700">${v}</label><input id="IN_${v}" type="text" value="0" style="width:48px">`;
    inputsArea.appendChild(box);
  });
}

function readInputs(){
  const assign = {};
  for(const v of currentVars){
    const el = document.getElementById('IN_'+v);
    if(!el) { assign[v]=false; continue; }
    const val = el.value.trim();
    if(!(val==='0' || val==='1')) return {ok:false, err:`Invalid value for ${v}: must be 0 or 1`};
    assign[v] = (val==='1');
  }
  return {ok:true, assign};
}

parseBtn.addEventListener('click', ()=>{
  try {
    const ast0 = parseExpression(exprInput.value);
    const ast = flattenToNAry(ast0);
    currentAST = ast;
    const s=new Set(); collectVars(ast,s);
    const vars = Array.from(s).sort();
    buildInputs(vars);
    const def = {}; vars.forEach(v=>def[v]=false);
    drawCircuit(svg, ast, def);
    buildTruthTable(ast);
    outputBadge.textContent = '—';
    setStatus('Parsed', true);
  } catch(err) {
    setStatus(String(err), false);
    currentAST = null;
    inputsArea.innerHTML=''; document.getElementById('tableWrap').innerHTML=''; svg.innerHTML='';
  }
});

applyBtn.addEventListener('click', ()=>{
  if(!currentAST){ setStatus('Parse expression first', false); return; }
  const r = readInputs();
  if(!r.ok){ setStatus(r.err, false); return; }
  drawCircuit(svg, currentAST, r.assign);
  const outv = evaluate(currentAST, r.assign);
  outputBadge.textContent = outv ? '1' : '0';
  setStatus('Inputs applied', true);
});

modeBtn.addEventListener('click', ()=>{
  document.body.classList.toggle('dark');
  modeBtn.textContent = document.body.classList.contains('dark') ? 'Light mode' : 'Dark mode';
});

// auto-parse default expression
parseBtn.click();

</script>
</body>
</html>

